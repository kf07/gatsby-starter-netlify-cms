---
templateKey: blog-post
title: 非同期処理 Promiseの使い方
date: 2018-11-03T07:51:23.120Z
description: javascript 非同期処理 Promiseの使い方
tags:
  - javascript
image: /img/javascript.jpg
---

## 非同期処理とは

例えば以下のコードを実行してみます

```javascript:

const func1 = () => {
  let msg = '#1';

  //#2
  setTimeout(() => {
    msg = `${msg}#2`;
  }, 10);

  //#3
  msg = `${msg}#3`;

  console.log(msg);
};

func1();
```

理想は 「#1#2#3」が出力されることですが  実際は「#1#3」が出力されます。  
これはsetTimeoutの#2の処理の終了を待たずに#3、console.logの処理が実行されてしまうからです。  
これを「非同期処理」といいます。


正しく動くようにpromiseを使ってみます。
```javascript:
const func2 = new Promise((resolve, reject) => {
  let msg = '#1';
  resolve(msg);
})
  .then(msg => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        msg = `${msg}#2`;
        resolve(msg);
      }, 10);
    });
  })
  .then(msg => {
    msg = `${msg}#3`;
    console.log(msg);
  });

```
## Promiseの使い方
Promiseは非同期処理の状態を監視するオブジェクト  

構文
```javascript:
new Promise((resolve,reject)=> {
})
```
関数の引数のresolve,rejectは非同期処理の成功と失敗を通知する関数です  
resolve:成功  
reject:失敗

引数の値が空ならreject、それ以外ならresolveを返す関数をつくってみます  

```javascript:
const promise1 = value => {
  return new Promise((resolve, reject) => {
    if (value) {
      //引数の値があるならresolveで引数を返す
      resolve(value);
    } else {
      //引数が空ならrejectで'エラー'を返す
      reject('エラー');
    }
  });
};

```

Promiseの結果はthenメソッドでresolveまたはrejectを受け取ります。  

thenメソッドの構文
```javascript:
promise.then(success,failure)
```
promise:Promiseオブジェクト  
success:成功コールバック関数(resolve関数によって呼び出し)  
failure:失敗コールバック関数(reject関数によって呼び出し）

実行結果はpromise1の引数が空なら「エラー」、それ以外ならpromise1の引数になります。  

実行結果  
#1
```javascript:
promise1('#1').then(
  result => {
    //promiseの結果がresolveの場合
    console.log(result);
  },
  error => {
    //promiseの結果がrejectの場合
    console.log(error);
  }
);

```

## 非同期処理の連結
Promiseオブジェクトは複数の非同期処理を連結することができます。  
以下のコードでは1回目の処理がresolveだったときにpromise1('#2')を実行します。  
1回目の処理がrejectだった場合はエラーが1回表示されるだけです。  

実行結果  
#1  
#2
```javascript:
promise1('#1')
  .then(
    result => {
    //promiseの結果がresolveの場合
    console.log(result);
　　//2回目のpromise1を実行
    return promise1('#2');
  })
  .then(
    result => {
      console.log(result);
    },

    error => {
      //promiseの結果がrejectの場合
      console.log(error);
    }
  );

```


## 複数の非同期処理を平行して実行する
### すべてresolveの場合に実行 Promise.all

構文
```javascript:
Promise.all([
監視するPromiseオブジェクト
])
```

Promise.allではすべての処理がresolveだった場合のみにsuccess(成功コールバック)が呼び出されます。  
その際、すべてのPromiseから渡された結果が配列で渡されます。
どれか1つでもrejectだった場合はfailure(失敗コールバック)が呼び出されます。


実行結果  
["#1", "#2", "#3"]  
3つあるpromise1のうち１つでも空の場合はエラーが1回表示される
```javascript:
Promise.all([
  promise1('#1'),
  promise1('#2'),
  promise1('#3')
]).then(
  result => {
    console.log(result)
  },
  error => {
    console.log(error)
  }
);
```
### 非同期処理のある1つが完了したところでコールバックする Promise.race
構文
```javascript:
Promise.race([
監視するPromiseオブジェクト
])
```
Promise.raceでは平行して実行した、いずれか1つが最初に完了したところでsuccess(成功コールバック)が呼び出されます。

実行結果  
#1 
```javascript:
Promise.race([
  promise1('#1'),
  promise1('#2'),
  promise1('#3')
]).then(
    result => {
      console.log(result);
    },
    error => {
      console.log(error);
    }
  );
```
処理に時間がかかる処理があった場合は実行結果が変わります。  
例えば、promise1を少し変更（setTimeoutを追加）したpromise2関数を作成して#1の処理を時間がかかる処理に変更してみます。  
すると、promise1("#2")が先に成功するため、実行結果は「#2」になります。
```javascript:

//promise2関数を作成
const promise2 = value => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (value) {
        //引数の値があるならresolveで引数を返す
        resolve(value);
      } else {
        //引数が空ならrejectで'エラー'を返す
        reject('エラー');
      }
    }, 200);
  });
};

//#1の処理をpromise2に変更
Promise.race([
  promise2('#1'),
  promise1('#2'),　//先に成功
  promise1('#3')
]).then(
    result => {
      console.log(result);
    },
    error => {
      console.log(error);
    }
  );
```

最初の処理をPromiseを使って書き直してみます。

Promise
